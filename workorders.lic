=begin
  Documentation: https://elanthipedia.play.net/Lich_script_repository#workorders
=end

custom_require.call(%w[common common-crafting common-items common-money common-travel drinfomon events])

class WorkOrders

    def initialize
        arg_definitions = [
        [
            { name: 'discipline', options: %w[blacksmithing weaponsmithing tailoring shaping carving remedies artificing], description: 'What type of workorder to do?' },
            { name: 'repair', regex: /repair/i, optional: true, description: 'repair tools instead of crafting' }
        ]
    ]

        args = parse_args(arg_definitions)
        work_order(args.discipline, args.repair)
    end

    def work_order(discipline, repair)
        @settings = get_settings
        crafting_data = get_data('crafting')
        @recipe_parts = crafting_data['recipe_parts']
        @bag = @settings.crafting_container
        @bag_items = @settings.crafting_items_in_container
        @hometown = @settings.crafting_hometown || @settings.hometown
        @use_own_ingot_type = @settings.use_own_ingot_type
        @deed_own_ingot = @settings.deed_own_ingot
        deeds_data = get_data('crafting').deeds[@hometown]
        @deeds_room = deeds_data['room']
        @deeds_number = deeds_data['medium_number']
        @carving_type = @settings.carving_workorder_material_type
        @min_items = @settings.workorder_min_items
        @max_items = @settings.workorder_max_items
        @recipe_overrides = @settings.workorder_recipes || {}
        @cash_on_hand = @settings.workorder_cash_on_hand
        @craft_max_mindstate = @settings.craft_max_mindstate
        @retain_crafting_materials = @settings.retain_crafting_materials
        @workorders_repair = @settings.workorders_repair
        @workorders_override_store = @settings.workorders_override_store
        @workorders_materials = @settings.workorders_materials
        @workorders_deed_storage = @settings.workorders_deed_storage || @bag
        @workorders_collect_herbs = @settings.workorders_collect_herbs

        Flags.add('proper-repair', 'Your excellent training in the ways of tool repair')

        DRC.wait_for_script_to_complete('safe-room', ['force']) if @settings.workorders_force_heal

        info =      if discipline =~ /weaponsmithing|armorsmithing/i
                        info = crafting_data['blacksmithing'][@hometown]
                    else
                        crafting_data[discipline][@hometown]
                    end

        recipes =   if @recipe_overrides[discipline]
                        get_data('recipes')[discipline].select { |recipe| @recipe_overrides[discipline].find { |name| recipe['name'] =~ /#{name}/i } }
                    else
                        get_data('recipes')[discipline].select { |recipe| recipe['work_order'] }
                    end

        recipes = discipline == 'carving' ? recipes.select { |x| x['material'] == @carving_type } : recipes

        unless repair
            if @settings.workorder_diff.is_a?(Hash)
                item_name, quantity = request_work_order(recipes, info['npc-rooms'], info['npc'], info['npc_last_name'], discipline, info['logbook'], @settings.workorder_diff[discipline])
            else
                item_name, quantity = request_work_order(recipes, info['npc-rooms'], info['npc'], info['npc_last_name'], discipline, info['logbook'], @settings.workorder_diff)
            end
            item = recipes.find { |r| r['name'] == item_name }
        end
        craft_method,book,script,base = [:craft_prep,'','','']

        case discipline
        when 'blacksmithing', 'weaponsmithing', 'armorsmithing'
            materials_info = crafting_data['stock'][@workorders_materials['metal_type']]
            skill,tools,@belt = ['Forging',@settings.forging_tools,@settings.forging_belt]
            craft_method = :forge_prep
        when 'tailoring'
            book,script = ['outfitting','sew']
            skill,tools,@belt,@work_room = ['Outfitting',@settings.outfitting_tools,@settings.outfitting_belt,@settings.outfitting_room]
            if item['chapter'] == 5
                base = 'yarn'
                materials_info = crafting_data['stock'][@workorders_materials['knit_type']]
            elsif [2,3,4].include?(item['chapter'])
                base = 'cloth'
                materials_info = crafting_data['stock'][@workorders_materials['fabric_type']]
            else
                base = 'leather'
                materials_info = crafting_data['stock'][@workorders_materials['leather_type']]
            end
        when 'shaping'
            book,script,base = ['engineering','shape','lumber']
            materials_info = crafting_data['stock'][@workorders_materials['wood_type']]
            skill,tools,@belt,@work_room = ['Engineering',@settings.shaping_tools,@settings.engineering_belt,@settings.engineering_room]
        when 'carving'
            book,script = ['engineering','carve']
            if @carving_type == 'bone'
                base = 'stack'
                materials_info = crafting_data['stock'][@workorders_materials['bone_type']]
            else
                materials_info = crafting_data['stock'][@workorders_materials['stone_type']]
                craft_method = :stone_prep
            end
            skill,tools,@belt,@work_room = ['Engineering',@settings.carving_tools,@settings.engineering_belt,@settings.engineering_room]
        when 'remedies'
            book,script,materials_info,craft_method = ['alchemy', 'slim-remedy',crafting_data['stock'],:remedy_prep]
            skill,tools,@belt,@work_room = ['Alchemy',@settings.alchemy_tools,@settings.alchemy_belt,@settings.alchemy_room]
        when 'artificing'
            book,script,materials_info,craft_method = ['enchanting','enchant',crafting_data['stock'],:enchant_prep]
            skill,tools,@belt,@work_room = ['Enchanting',@settings.enchanting_tools,@settings.enchanting_belt,@settings.enchanting_room]
        else
            echo 'No discipline found?'
            return
        end

        if repair && @workorders_repair_own_tools
            repair_own_tools(info, tools)
            exit
        elsif repair
            tool_drop(info, tools)
            tool_pickup(info)
            exit
        end

        if DRSkill.getxp(skill) > @craft_max_mindstate
            echo("Exiting because your current mindstate for #{skill} over the set maximum craft_max_mindstate:#{@craft_max_mindstate}")
            exit
        end

        total_cost = DRCC.crafting_cost(item, @hometown, skill = 'Alchemy' ? item['part']+['alcohol','water','coal'] : item['part'], quantity, (skill =~ /alchemy|enchanting/i) || (skill == 'Forging' && @use_own_ingot_type) ? false : materials_info)
        total_cost += 5000 if @workorders_repair
        DRCM.ensure_copper_on_hand(total_cost, @settings, @hometown)

        send(craft_method, info, materials_info, item, quantity, book, script, base)

        tool_drop(info, tools) if @workorders_repair

        complete_work_order(info)

        tool_pickup(info)

        repair_own_tools(info, tools) if @workorders_repair_own_tools
    end

################             REPAIR                ######################

    def repair_own_tools(info, tools)
        current = Room.current.id
        DRCM.ensure_copper_on_hand(1500, @settings)
        DRCT.walk_to(current)
        DRCC.repair_own_tools(get_data('crafting')['blacksmithing'][@hometown], tools, @bag, @bag_items, @belt)
    end

    def tool_drop(info, tools) # accepts array of tools for repair
        DRCT.walk_to(info['repair-room'])
        tools.each do |tool_name|
            DRCC.get_crafting_item(tool_name, @bag, @bag_items, @belt, true)
            next unless DRC.right_hand
            case DRC.bput("give #{info['repair-npc']}", "I don't repair those here", 'What is it', "There isn't a scratch on that", 'Just give it to me again', 'I will not', "I can't fix those.  They only have so many uses and then you must buy another.")
            when /give/
                DRC.bput("give #{info['repair-npc']}", 'repair ticket')
                DRC.bput('stow ticket', 'You put')
            else
                DRCC.stow_crafting_item(tool_name, @bag, @belt)
            end
        end
    end

    def tool_pickup(info) # picks up all your tools from repair shop
        while /You get/ =~ DRC.bput("get my #{info['repair-npc']} ticket", /^You get/, /^You are already/, /^You're already/, /What were you referring to/)
            DRCT.walk_to(info['repair-room'])
            pause 30 until DRC.bput('look at my ticket', 'should be ready by now', 'Looking at the') == 'should be ready by now'
            DRC.bput("give #{info['repair-npc']}", 'You hand')
            pause 0.01 until tool = [DRC.right_hand,DRC.left_hand].compact.first # waits for tool to hit your hand
            belts = [@settings.forging_belt, @settings.engineering_belt, @settings.outfitting_belt, @settings.alchemy_belt, @settings.enchanting_belt]
            toolbelt = belts.select { |belt| belt["items"].find { |name| name =~ /#{tool}/i } }.first # searches your toolbelts for the first one containing the tool.
            DRCC.stow_crafting_item(tool, @bag, toolbelt) # hopefully stows the tool appropriately.
        end
    end

################           WORK SECTION            ######################

    def craft_prep(info, materials_info, item, quantity, book, script, base)
        base_to_buy,scrap = calc_stock(materials_info, item, quantity, base)
        buy_material_stackables(info, materials_info, quantity, base_to_buy, base) if base_to_buy
        order_parts(item['part'], quantity) if item['part']
        DRCC.find_shaping_room(@hometown, @work_room)
        while check_logbook_count(book, quantity)
            DRC.wait_for_script_to_complete(script, [item['chapter'], item['name'], materials_info['stock-name'], item['noun']])
            DRCC.logbook_item(book, item['noun'], @bag)
        end
        trash_crafting_items("#{materials_info['stock-name']} #{base}", info) if scrap && !@retain_crafting_materials
    end

    def stone_prep(info, materials_info, item, quantity, book, script, base)
        buy_material_singles(info, materials_info, quantity)
        order_parts(item['part'], quantity) if item['part']
        DRCC.find_shaping_room(@hometown)
        while check_logbook_count("engineering", quantity)
            DRC.wait_for_script_to_complete('carve', [item['chapter'], item['name'], materials_info['stock-name'], item['noun']])
            DRCC.logbook_item('engineering', item['noun'], @bag)
        end
    end

    def remedy_prep(info, materials_info, item, quantity, book, script, base)
        leftovers = buy_remedies(info, materials_info, item, quantity)
        echo leftovers
        @bag_items << leftovers
        DRCT.walk_to(@work_room)
        while check_logbook_count("alchemy", quantity)
            DRC.wait_for_script_to_complete('slim-remedy', [item['name']])
            DRCC.logbook_item('alchemy', item['noun'], @bag)
        end
        echo leftovers
        leftovers.each { |part| trash_crafting_items(part, info) }
    end

    def enchant_prep(info, materials_info, item, quantity, book, script, base)
        item['part'].each do |part|
            buy_material_singles(info, materials_info[part], quantity, part)
        end
        DRCC.fount(info['tool-room'], 1, info['fount'], quantity, @bag, @bag_items, @belt)
        DRCI.stow_hands
        # Start crafting #
        DRCC.find_enchanting_room(@hometown, @work_room)
        while check_logbook_count("enchanting", quantity)
            DRC.wait_for_script_to_complete('enchant', [item['chapter'], item['name'], item['noun']])
            DRCC.logbook_item('enchanting', item['noun'], @bag)
        end
    end

    def forge_prep(info, materials_info, item, quantity, book, script, base)
        unless @use_own_ingot_type && check_own_ingot(item, quantity)
            buy_material_singles(info, materials_info, quantity)
            base,scrap = calc_stock(materials_info, item, quantity, 'ingot')
        end
        while check_logbook_count("forging", quantity)
            DRC.wait_for_script_to_complete('smith', [materials_info['stock-name'], item['name']])
            DRCC.logbook_item('forging', item['noun'], @bag)
            DRCT.dispose("#{materials_info['stock-name']} ingot") if scrap
        end
        smelt if @smelt
        deed_item("#{@use_own_ingot_type} ingot") if @deed_own_ingot
    end

    def check_logbook_count(craft, quantity)
        count ||= quantity + 1
        return false if count <= 0
        if /(\d)/ =~ DRC.bput("read my #{craft} logbook", /This work order appears to be complete/, /You must bundle and deliver (\d+) more/, /^This logbook is not currently tracking any work orders/)
            return true
        else
            false
        end
    end

################        MATERIALS HANDLING         ######################

    def buy_material_singles(info, materials_info, quantity, name = '')
        # Buy single, non-stackable materials eg rock deeds, ingots, herbs
        quantity.times do
            if materials_info['stock-number']
                DRCT.order_item(info['stock-room'], materials_info['stock-number'])
                DRCC.stow_crafting_item([DRC.left_hand,DRC.right_hand].compact.first, @bag, nil)
            else
                DRCT.buy_item(info['stock-room'], name)
                DRCC.stow_crafting_item(name, @bag, nil)
            end
        end
    end

    def buy_material_stackables(info, materials_info, quantity, base_to_buy, base)
        # Buy stackable materials eg lumber/bone stacks
        # Total volume for max count workorder needs to be under total stackable size
        base_to_buy.times do
            DRCT.order_item(info['stock-room'], materials_info['stock-number'])
            fput("combine #{base}")
        end
        DRCC.stow_crafting_item(base, @bag, nil)
    end

    def buy_remedies(info, materials_info, item, quantity)
        herb_list = ['crushed flowers', 'muljin','belradi','dioica','hulnik','aloe','eghmok','lujeakave','yelith','cebi','blocil','hulij','nuloe','hisan']
        if herb_list.include?(item['part'].first)
            collect_and_process(item, item['part'].first, quantity)
        else
            quantity.times { buy_material_singles(info, materials_info[item['part'].first], 1, item['part'].first) } # Buy one  main herb stack for each remedy to craft
        end
        item['part'].shift && item['part'] += ['water', 'alcohol'] # Update our parts list to remove the herb we've already purchased, and add the bits we might need
        item['part'].each { |part| buy_material_singles(info, materials_info[part], 1, part) } # purchase one of each of these bits
        buy_material_singles(get_data('crafting')['blacksmithing'][@hometown], materials_info['coal'], 1, 'nugget') && item['part'] += ['coal nugget'] # Buy a single coal nugget, plenty, and add it to our parts list
        return item['part'] # Return a list of parts for disposal at the end.
    end

    def calc_stock(materials_info, recipe, quantity, base = '')
        total_needed = quantity*recipe['volume']
        if base == 'ingot'
            scrap = (recipe['volume'])%materials_info['stock-volume'] > 0 ? true : false # if any left after division (%) we'll have to toss the extra bits between crafts
            return [nil, scrap] # These are not stackable, so we just need to determine if there will be leftovers out of each ingot
        elsif DRCI.exists?("#{materials_info['stock-name']} #{base}")
            /(\d+)/ =~ DRC.bput("count my #{materials_info['stock-name']} #{base}", /^You count out (\d+) (pieces|yards) of (lumber|material)/)
            on_hand_stock = Regexp.last_match(1).to_i
            return [false,false] if on_hand_stock >= (total_needed) # We have what we need, so no need to buy more.
            total_needed -= on_hand_stock # How many do we need to buy to add to what we already have.
            DRC.bput("get my #{materials_info['stock-name']} #{base} from my #{@bag}", /^You get/, /^You are already/, /^You're already/, /What were you referring to/) # have in hand to combine
        end
        
        base_to_buy = (total_needed/materials_info['stock-volume'].to_f).ceil
        scrap = (total_needed)%materials_info['stock-volume'] > 0 ? true : false

        [base_to_buy, scrap]
    end

################          PARTS HANDLING           ######################

    def buy_parts(parts, partroom)
        parts.each do |part|
            DRCT.buy_item(partroom, part)
            DRCC.stow_crafting_item(part, @bag, @belt)
        end
    end

    def order_parts(parts, quantity)
        parts.each do |part|
            data = @recipe_parts[part][@hometown]
            quantity.times do
                if data['part-number']
                    DRCT.order_item(data['part-room'], data['part-number'])
                else
                    DRCT.buy_item(data['part-room'], part)
                end
                DRCC.stow_crafting_item(part, @bag, @belt)
            end
        end
    end
    
    def trash_crafting_items(trash, info)
        DRCT.walk_to(info['trash-room'])
        DRCC.get_crafting_item(trash, @bag, @bag_items, @belt)
        DRCI.dispose_trash(trash)
    end

################    PERSONAL MATERIALS HANDLING    ######################

    ## TODO 
    ## 1. use_own_lumber
    ## 2. consolidate, maybe even move entirely to calc

    def collect_and_process(recipe, herb_needed, quantity) # requires significant outdoorsmanship skill and somewhat careful selection of an outdoors room. Alternative is just foraging and processing your own.
        unless @workorders_collect_herbs
            quantity.times { redeem_deed(herb_needed) }
            return
        end
        forage_name = ['muljin sap','belradi moss','dioica sap','hulnik grass','aloe leaves','eghmok moss','lujeakave root','yelith root','cebi root','blocil berries','hulij leaves','nuloe stem','hisan flower']
        herb = forage_name.find { |h| h.include?(herb_needed) } || 'blue flowers' # crushed flowers is the special case here, so unless we find a match, it becomes crushed flowers.
        DRCT.walk_to(@settings.outdoors_room)
        flowers,needed = [0,quantity] # number of individual flower stacks, representing 1 does, and 25 count stacks, representing 5 doses
        until flowers >= 5*quantity
            unless /manage/ =~ DRC.bput("collect #{herb}", /^You manage to collect/, /^You.*(forage|wander) around/, /^You find something dead/)
                DRC.message("Failed to collect #{herb}. Either it cannot be found here or you don't have the skill to collect it.\nYou will have to collect your own herbs for this recipe going forwards.\nChange yaml setting: workorders_collect_herbs to false.")
                exit
            end
            until /Stow what/ =~ DRC.bput("stow #{herb}", /^You put your/, /^Stow what/)
                flowers += 1
            end
        end
        DRCT.walk_to(get_data('crafting')['remedies'][@hometown]['press-grinder-rooms'].first)
        process = recipe['container'] == 'bowl' ? "put my #{herb} in grinder" : "put my #{herb} in press"
        quantity.times do
            5.times do
                DRC.bput("get #{herb} from my carryall", /^You get/, /^You are already/, /^You're already/, /What were you referring to/)
                DRC.bput(process, /^You place some/)
                DRC.bput("combine", /^You must be holding/, /^You combine/)
                flowers -= 1
            end
            DRCC.stow_crafting_item(DRC.left_hand, @bag, nil)
            needed -= 1
        end
        until /referring/ =~ DRC.bput("get my #{herb}", /^You get/, /^You are already/, /^You're already/, /What were you referring to/)
            DRCI.dispose_trash(herb)
        end
    end

    def redeem_deed(deed_type, base)
        unless /referring/ =~ DRC.bput("get #{$ORDINALS.first} #{deed_type} deed from my #{@workorders_deed_storage}", /^You get/, /^You are already/, /^You're already/, /What were you referring to/) || [DRC.right_hand,DRC.left_hand].compact.include?("deed")
            if /explains/ =~ DRC.bput("tap my deed", /^An attendant arrives/, /^The worker explains/)
                DRCC.stow_crafting_item('deed', @bag, nil)
                $ORDINALS.shift
                redeem_deed(deed_type)
            end
            pause 0.5
            DRC.bput("get #{deed_type} #{base}", /^You pick up/) unless checkleft || checkright
            DRCC.stow_crafting_item([DRC.right_hand,DRC.left_hand].compact, @bag, nil)
        else
            DRC.message("Missing the required deeds for #{deed_type}")
            exit
        end
    end

    def deed_item(item)
        unless DRC.bput('look my deed packet', /You count \d+ deed claim forms remaining/, /I could not find what you were referring to/) =~ /You count \d+ deed claim forms remaining/
            DRCM.ensure_copper_on_hand(@cash_on_hand || 10_000, @settings)
            DRCT.order_item(@deeds_room, @deeds_number)
        end
        DRC.bput("get my packet", /^You get/, /^You are already/, /^You're already/, /What were you referring to/)
        DRC.bput("get my #{item}", /^You get/, /^You are already/, /^You're already/, /What were you referring to/)
        DRC.bput("push my #{item} with packet", /^You push/)
        [DRC.right_hand,DRC.left_hand].compact.each do |item|
            DRCC.stow_crafting_item(item, @bag, nil)
        end
    end

    def ingot_volume(material)
        DRC.bput("analyze my #{material} ingot", /About \d+ volume/).scan(/\d+/).first.to_i
    end

    def deed_volume(material)
        DRC.bput("read my #{material} deed", /Volume:\s*\d+/, /Amount:\s*\d+/).scan(/\d+/).first.to_i
    end

    def check_own_ingot(item, quantity)
        if /referring/ =~ DRC.bput("get my #{@use_own_ingot_type} ingot", /^You get/, /^You are already/, /^You're already/, /What were you referring to/) 
            if /referring/ =~ DRC.bput("get my #{@use_own_ingot_type} deed", /^You get/, /^You are already/, /^You're already/, /What were you referring to/)
                echo('out of material/deeds')
                return false
            else
                volume = deed_volume(@use_own_ingot_type)
                redeem_deed(@use_own_ingot_type)
            end
        end

        volume ||= ingot_volume(@use_own_ingot_type)

        DRCI.stow_hands
        @smelt = false

        if volume < quantity * item['volume']
            @smelt = true
            if /referring/ =~ DRC.bput("get my #{@use_own_ingot_type} deed", /^You get/, /^You are already/, /^You're already/, /What were you referring to/)
                echo('out of material/deeds')
                return false
            else
                volume = deed_volume(@use_own_ingot_type)
                redeem_deed(@use_own_ingot_type)
            end
            volume = ingot_volume(@use_own_ingot_type)
        end

        DRCI.stow_hands

        if volume < quantity * item['volume']
            echo('out of material/deeds')
            smelt
            return check_own_ingot(item, quantity)
        end

        true
    end

    def smelt
        DRCC.find_empty_crucible(@hometown)
        2.times do
            DRC.bput("get my #{@use_own_ingot_type} ingot", /^You get/, /^You are already/, /^You're already/, /What were you referring to/)
            fput('put my ingot in cruc')
        end
        DRC.wait_for_script_to_complete('smelt')
        DRCI.stow_hands
    end

################       TASK MASTER HANDLING        ######################

    def request_work_order(recipes, npc_rooms, npc, npc_last_name, discipline, logbook, diff)
        match_names = recipes.map { |x| x['name'] }
        diff ||= 'challenging'
        DRCI.stow_hands
        500.times do
            find_npc(npc_rooms, npc_last_name)
            DRC.bput("get my #{logbook} logbook", 'You get') unless DRC.left_hand || DRC.right_hand
            case DRC.bput("ask #{npc} for #{diff} #{discipline} work", '^To whom', 'order for .* I need \d+ ', 'order for .* I need \d+ stacks \(5 uses each\) of .* quality', 'You realize you have items bundled with the logbook', 'You want to ask about shadowlings')
            when 'You want to ask about shadowlings'
                pause 10
                fput('say Hmm.')
            when /order for (.*)\. I need (\d+) /
                item = Regexp.last_match(1)
                quantity = Regexp.last_match(2).to_i
                if @min_items <= quantity && quantity <= @max_items && match_names.include?(item)
                    DRCC.stow_crafting_item('logbook', @bag, nil)
                    return [item, quantity]
                end
            when /order for (.*)\. I need (\d+) stacks \(5 uses each\) of .* quality/
                item = Regexp.last_match(1)
                quantity = Regexp.last_match(2).to_i
                if @min_items <= quantity && quantity <= @max_items && match_names.include?(item)
                    DRCC.stow_crafting_item('logbook')
                    return [item, quantity]
                end
            when 'You realize you have items bundled with the logbook'
                DRC.bput('untie my logbook', 'You untie')
                if DRC.left_hand.include?('logbook')
                    fput("drop my #{DRC.right_hand}")
                else
                    fput("drop my #{DRC.left_hand}")
                end
                fput('get logbook') unless [DRC.left_hand, DRC.right_hand].grep(/logbook/i).any?
            end
        end
        DRCC.stow_crafting_item('logbook', @bag, nil)
        exit
    end

    def complete_work_order(info)
        DRCI.stow_hands
        loop do
            find_npc(info['npc-rooms'], info['npc_last_name'])
            DRC.bput("get my #{info['logbook']} logbook", 'You get')
            DRC.release_invisibility
            case DRC.bput("give my #{info['logbook']} logbook to #{info['npc']}", /You hand/, /You can/, /What were you/, /Apparently the work order time limit has expired/, /The work order isn\'t yet complete/, /What is it you\'re trying to give/)
            when /You can/, /What were you/, /What is it/
                next
            end
            break
        end
        DRCC.stow_crafting_item('logbook', @bag, nil)
    end

    def find_npc(room_list, npc)
        room_list.each do |room_id|
            break if DRRoom.npcs.include?(npc)
            DRCT.walk_to(room_id)
        end
    end
end

before_dying do
  Flags.delete('proper-repair')
end

WorkOrders.new
