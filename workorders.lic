=begin
  Documentation: https://elanthipedia.play.net/Lich_script_repository#workorders
=end

custom_require.call(%w[common common-crafting common-items common-money common-travel drinfomon events])

class WorkOrders

    def initialize
        arg_definitions = [
        [
            { name: 'discipline', options: %w[blacksmithing weaponsmithing tailoring shaping carving remedies artificing], description: 'What type of workorder to do?' },
            { name: 'train', regex: /train/i, optional: true, description: 'train a particular craft to high mindstate instead of doing a workorder for prestige' },
            { name: 'repair', regex: /repair/i, optional: true, description: 'repair tools instead of crafting' }
        ]
        ]

        args = parse_args(arg_definitions)
        @settings = get_settings
        @ordinals = $ORDINALS
        @crafting_data = get_data('crafting')
        @recipe_parts = @crafting_data['recipe_parts']
        @bag = @settings.crafting_container
        @bag_items = @settings.crafting_items_in_container
        @hometown = @settings.crafting_hometown || @settings.hometown
        deeds_data = get_data('crafting').deeds[@hometown]
        @deeds_room = deeds_data['room']
        @deeds_number = deeds_data['medium_number']
        @carving_type = @settings.carving_workorder_material_type
        @min_items = @settings.workorder_min_items
        @max_items = @settings.workorder_max_items
        @recipe_overrides = @settings.workorder_recipes || {}
        @cash_on_hand = @settings.workorder_cash_on_hand
        @craft_max_mindstate = @settings.craft_max_mindstate
        @retain_crafting_materials = @settings.retain_crafting_materials
        @workorders_repair = @settings.workorders_repair
        @workorders_override_store = @settings.workorders_override_store
        @workorders_repair_own_tools = @settings.workorders_repair_own_tools
        @workorders_materials = @settings.workorders_materials
        @workorders_deed_storage = @settings.workorders_deed_storage || @bag
        @workorders_collect_herbs = @settings.workorders_collect_herbs
        Flags.add('proper-repair', 'Your excellent training in the ways of tool repair')
        DRC.wait_for_script_to_complete('safe-room', ['force']) if @settings.workorders_force_heal

        if args.train
            train_craft(args.discipline.downcase)
        else
            work_order(args.discipline, args.repair)
        end
    end

    def train_craft(discipline)
        @skip_logging = true

        train_map = {
            'tailoring' => {25=>'some knitted socks',50=>'some knitted mittens',100=>'a knitted hat',200=>'some knitted gloves',300=>'some knitted hose',425=>'a knitted cloak',500=>'a cloth haversack',600=>'a deeply-hooded cloak',850=>"some flowing cloth robes",1000=>'a cloth mining belt',1400=>"a cloth survival belt",1750=>"a cloth artisan's belt"},
            'shaping'=> {25=>'a wood band',50=>'a wood bracelet',100=>'a wood cloak pin',200=>'a wood amulet',300=>'a wood brooch',425=>'a wood armband',500=>'a wood choker',600=>'an articulated wood necklace',850=>'a wood crown',1000=>'a wood comb',1400=>'a wood haircomb',1750=>'a detailed wood statue'},
            'blacksmithing'    => {25=>'a shallow metal cup',50=>'a short metal mug',100=>'a back scratcher',200=>'a small metal flask',300=>'a metal lockpick ring',425=>'a metal armband',500=>'some metal clippers',600=>'a triangular wire sieve',850=>'a serrated hide scraper',1000=>'a metal mask',1400=>'some thin sewing needles',1750=>'a trapezoidal wire sieve'},
            'remedies'    => {25=>'some blister cream',50=>'some moisturizing ointment',100=>'some chest salve',200=>'a neck potion',300=>'some limb salve',425=>'some chest ungent',500=>'some neck tonic',600=>'some eye tonic',850=>'a body elixir',1000=>'a general elixir',1400=>'some refreshment elixir',1750=>'some vigor poultices'},
            'artificing' => {25=>'a radiant trinket',50=>'a mana trinket',100=>'a wind trinket',200=>'an earth trinket',300=>'a fire trinket',425=>'a water trinket',500=>'simple gwethsmasher',600=>'a destructive focus',850=>'a fire focus',1000=>'a frost focus',1400=>'an electric focus',1750=>'an electric focus'}
          }
        rank_map = {'tailoring'=>'Outfitting','shaping'=>'Engineering','blacksmithing'=>'Forging','remedies'=>'Alchemy','artificing'=>'Enchanting'}
        
        unless train_map[discipline]
            DRC.message("#{discipline} is not currently supported for training option. Options include: tailoring, shaping, blacksmithing, remedies, and artificing.")
            exit
        end
        quantity = (34 - DRSkill.getxp(rank_map[discipline]))/10 # sets quantity based on current mindstate, max of 3 items.
        
        unless quantity > 0 # mindstate of 25 or greater ends the training prematurely
            DRC.message("Current mindstate in #{discipline} is #{DRSkill.getxp(rank_map[discipline])}, which is above training threshold of 25. Exiting")
            exit
        end

        recipe_name = train_map[discipline].find { |rank,item| DRSkill.getrank(rank_map[discipline]) <= rank }.last
        info = @crafting_data[discipline][@hometown]
        item = get_data('recipes')[discipline].find { |recipe| recipe_name == recipe['name'] }
        craft_method,book,script,base,skill,tools,@belt,@work_room,materials_info = set_discipline_info(discipline, item)

        
        send(craft_method, info, materials_info, item, quantity, book, script, base)

        tool_drop(get_data('crafting')['shaping'][@hometown], tools) if @workorders_repair && !@workorders_repair_own_tools

        tool_pickup(get_data('crafting')['shaping'][@hometown]) && !@workorders_repair_own_tools

        repair_own_tools(info, tools) if @workorders_repair_own_tools
    end

    def work_order(discipline, repair)
        recipes =   if @recipe_overrides[discipline]
                        get_data('recipes')[discipline].select { |recipe| @recipe_overrides[discipline].find { |name| recipe['name'] =~ /#{name}/i } }
                    else
                        get_data('recipes')[discipline].select { |recipe| recipe['work_order'] }
                    end

        info =      if discipline =~ /weaponsmithing|armorsmithing/i
                        @crafting_data['blacksmithing'][@hometown]
                    else
                        @crafting_data[discipline][@hometown]
                    end

        recipes = discipline == 'carving' ? recipes.select { |x| x['material'] == @carving_type } : recipes

        unless repair
            if @settings.workorder_diff.is_a?(Hash)
                item_name, quantity = request_work_order(recipes, info['npc-rooms'], info['npc'], info['npc_last_name'], discipline, info['logbook'], @settings.workorder_diff[discipline])
            else
                item_name, quantity = request_work_order(recipes, info['npc-rooms'], info['npc'], info['npc_last_name'], discipline, info['logbook'], @settings.workorder_diff)
            end
            item = recipes.find { |r| r['name'] == item_name }
        end
        
        craft_method,book,script,base,skill,tools,@belt,@work_room,materials_info = set_discipline_info(discipline, item)

        if repair && @workorders_repair_own_tools
            repair_own_tools(info, tools)
            exit
        elsif repair
            tool_drop(info, tools)
            tool_pickup(info)
            exit
        end

        total_cost = DRCC.crafting_cost(item, @hometown, skill = 'Alchemy' ? item['part']+['alcohol','water','coal'] : item['part'], quantity, (skill =~ /alchemy|enchanting/i) || (skill == 'Forging' && @workorders_materials['custom'][base]) ? false : materials_info)
        total_cost += 5000 if @workorders_repair
        DRCM.ensure_copper_on_hand(total_cost, @settings, @hometown)


        send(craft_method, info, materials_info, item, quantity, book, script, base)

        tool_drop(get_data('crafting')['shaping'][@hometown], tools) if @workorders_repair && !@workorders_repair_own_tools

        complete_work_order(info)

        tool_pickup(get_data('crafting')['shaping'][@hometown]) if @workorders_repair && !@workorders_repair_own_tools

        repair_own_tools(info, tools) if @workorders_repair_own_tools
    end
    
    def set_discipline_info(discipline, item)


        craft_method,book,script,base = [:craft_prep,'','','']
        case discipline
        when 'blacksmithing', 'weaponsmithing', 'armorsmithing'
            materials_info = @crafting_data['stock'][@workorders_materials['metal_type']]
            skill,tools,@belt = ['Forging',@settings.forging_tools,@settings.forging_belt]
            base = 'ingot'
            craft_method = :forge_prep
        when 'tailoring'
            book,script = ['outfitting','sew']
            skill,tools,@belt,@work_room = ['Outfitting',@settings.outfitting_tools,@settings.outfitting_belt,@settings.outfitting_room]
            if item['chapter'] == 5
                base = 'yarn'
                materials_info = @crafting_data['stock'][@workorders_materials['knit_type']]
            elsif [2,3,4].include?(item['chapter'])
                base = 'cloth'
                materials_info = @crafting_data['stock'][@workorders_materials['fabric_type']]
            else
                base = 'leather'
                materials_info = @crafting_data['stock'][@workorders_materials['leather_type']]
            end
        when 'shaping'
            book,script,base = ['engineering','shape','lumber']
            materials_info = @crafting_data['stock'][@workorders_materials['wood_type']]
            skill,tools,@belt,@work_room = ['Engineering',@settings.shaping_tools,@settings.engineering_belt,@settings.engineering_room]
        when 'carving'
            book,script = ['engineering','carve']
            if @carving_type == 'bone'
                base = 'stack'
                materials_info = @crafting_data['stock'][@workorders_materials['bone_type']]
            else
                materials_info = @crafting_data['stock'][@workorders_materials['stone_type']]
                craft_method = :stone_prep
            end
            skill,tools,@belt,@work_room = ['Engineering',@settings.carving_tools,@settings.engineering_belt,@settings.engineering_room]
        when 'remedies'
            book,script,materials_info,craft_method = ['alchemy', 'slim-remedy',@crafting_data['stock'],:remedy_prep]
            skill,tools,@belt,@work_room = ['Alchemy',@settings.alchemy_tools,@settings.alchemy_belt,@settings.alchemy_room]
        when 'artificing'
            book,script,materials_info,craft_method = ['enchanting','enchant',@crafting_data['stock'],:enchant_prep]
            skill,tools,@belt,@work_room = ['Enchanting',@settings.enchanting_tools,@settings.enchanting_belt,@settings.enchanting_room]
        end

        return [craft_method,book,script,base,skill,tools,@belt,@work_room,materials_info]
    end

################             REPAIR                ######################

    def repair_own_tools(info, tools)
        current = Room.current.id
        DRCM.ensure_copper_on_hand(1500, @settings)
        DRCT.walk_to(current)
        DRCC.repair_own_tools(get_data('crafting')['blacksmithing'][@hometown], tools, @bag, @bag_items, @belt)
    end

    def tool_drop(info, tools) # accepts array of tools for repair
        DRCT.walk_to(info['repair-room'])
        tools.each do |tool_name|
            DRCC.get_crafting_item(tool_name, @bag, @bag_items, @belt, true)
            next unless DRC.right_hand
            case DRC.bput("give #{info['repair-npc']}", "I don't repair those here", 'What is it', "There isn't a scratch on that", 'Just give it to me again', 'I will not', "I can't fix those.  They only have so many uses and then you must buy another.")
            when /give/
                DRC.bput("give #{info['repair-npc']}", 'repair ticket')
                DRC.bput('stow ticket', 'You put')
            else
                DRCC.stow_crafting_item(tool_name, @bag, @belt)
            end
        end
    end

    def tool_pickup(info) # picks up all your tools from repair shop
        while /You get/ =~ DRC.bput("get my #{info['repair-npc']} ticket", /^You get/, /^You are already/, /^You're already/, /What were you referring to/)
            DRCT.walk_to(info['repair-room'])
            pause 30 until DRC.bput('look at my ticket', 'should be ready by now', 'Looking at the') == 'should be ready by now'
            DRC.bput("give #{info['repair-npc']}", 'You hand')
            pause 0.01 until tool = [DRC.right_hand,DRC.left_hand].compact.first # waits for tool to hit your hand
            belts = [@settings.forging_belt, @settings.engineering_belt, @settings.outfitting_belt, @settings.alchemy_belt, @settings.enchanting_belt]
            toolbelt = belts.select { |belt| belt["items"].find { |name| name =~ /#{tool}/i } }.first # searches your toolbelts for the first one containing the tool.
            DRCC.stow_crafting_item(tool, @bag, toolbelt) # hopefully stows the tool appropriately.
        end
    end

################           WORK SECTION            ######################

    def craft_prep(info, materials_info, item, quantity, book, script, base)
        unless @workorders_materials['custom'][base] && check_own_materials(item, quantity, @workorders_materials['custom'][base], base)
            type = materials_info['stock-name']
            base_to_buy,scrap = calc_stock(materials_info, item, quantity, base)
            buy_material_stackables(info, materials_info, quantity, base_to_buy, base) if base_to_buy
        else
            type = @workorders_materials['custom'][base]
        end

        order_parts(item['part'], quantity) if item['part']
        DRCC.find_shaping_room(@hometown, @work_room)
        quantity.times do
            if @skip_logging
                DRC.wait_for_script_to_complete(script, [item['chapter'], item['name'], type, item['noun']])
                DRCI.dispose_trash(item['noun'])
                break if DRSkill.getxp(book.capitalize) > 28
            else
                break unless check_logbook_count(book, quantity)
                DRC.wait_for_script_to_complete(script, [item['chapter'], item['name'], type, item['noun']])
                DRCC.logbook_item(book, item['noun'], @bag)
            end
        end

        if @workorders_materials['custom'][base] && DRCI.exists?("#{type} #{base}")
            deed_item("#{type} #{base}")
        else
            trash_crafting_item("#{materials_info['stock-name']} #{base}", info) if scrap && !@retain_crafting_materials
        end
    end

    def stone_prep(info, materials_info, item, quantity, book, script, base)
        buy_material_singles(info, materials_info, quantity)
        order_parts(item['part'], quantity) if item['part']
        DRCC.find_shaping_room(@hometown)
        quantity.times do
            break unless check_logbook_count("engineering", quantity)
            DRC.wait_for_script_to_complete('carve', [item['chapter'], item['name'], materials_info['stock-name'], item['noun']])
            DRCC.logbook_item('engineering', item['noun'], @bag)
        end
    end

    def remedy_prep(info, materials_info, item, quantity, book, script, base)
        leftovers = buy_remedies(info, materials_info, item, quantity)
        @bag_items << leftovers
        DRCT.walk_to(@work_room)
        quantity.times do
            DRC.wait_for_script_to_complete('slim-remedy', [item['name']])
            name = DRC.right_hand
            if @skip_logging
                DRCI.dispose_trash(name)
                break if DRSkill.getxp('Alchemy') > 28
            else
                break if finished_remedies(name, quantity) >= quantity*5
                DRCC.stow_crafting_item(name, @bag, nil)
            end
        end
        log_remedy(item['noun'], quantity)
        leftovers.each { |part| trash_crafting_item(part, info) }
    end

    def enchant_prep(info, materials_info, item, quantity, book, script, base)
        item['part'].each do |part|
            buy_material_singles(info, materials_info[part], quantity, part)
        end
        DRCC.fount(info['tool-room'], 1, info['fount'], quantity, @bag, @bag_items, @belt)
        DRCI.stow_hands
        # Start crafting #
        DRCC.find_enchanting_room(@hometown, @work_room)
        quantity.times do
            DRC.wait_for_script_to_complete('enchant', [item['chapter'], item['name'], item['noun']])
            if @skip_logging                
                DRCI.dispose_trash(item['noun'].split(' ').last)
                break if DRSkill.getxp('Enchanting') > 28
            else
                DRCC.logbook_item('enchanting', item['noun'].split(' ').last, @bag)
            end
        end
    end
    ## TODO:
    # 1. ingot calcs, minimizing waste on purchases
    # 2. bingots with above

    def forge_prep(info, materials_info, item, quantity, book, script, base)
        unless @workorders_materials['custom'][base] && check_own_ingot(item, quantity, @workorders_materials['custom'][base])
            buy_material_singles(info, materials_info, quantity)
            base,scrap = calc_stock(materials_info, item, quantity, base)
        end
        quantity.times do
            if @skip_logging
                DRC.wait_for_script_to_complete('smith', [materials_info['stock-name'], item['name']])
                DRCI.dispose_trash(item['noun'])
                break if DRSkill.getxp('Forging') > 28
            else
                break unless check_logbook_count("forging", quantity)
                DRC.wait_for_script_to_complete('smith', [materials_info['stock-name'], item['name']])
                DRCC.logbook_item('forging', item['noun'], @bag)
            end            
            DRCT.dispose("#{materials_info['stock-name']} ingot") if scrap
        end
        smelt(@workorders_materials['custom'][base]) if @smelt
        deed_item("#{@workorders_materials['custom'][base]} #{base}") if @workorders_materials['custom'][base]
    end

    def check_logbook_count(craft, quantity)
        /(\d)/ =~ DRC.bput("read my #{craft} logbook", /This work order appears to be complete/, /You must bundle and deliver (\d+) more/, /^This logbook is not currently tracking any work orders/)
    end

################        MATERIALS HANDLING         ######################

    def buy_material_singles(info, materials_info, quantity, name = '')
        # Buy single, non-stackable materials eg rock deeds, ingots, herbs
        quantity.times do
            if materials_info['stock-number']
                DRCT.order_item(info['stock-room'], materials_info['stock-number'])
                DRCC.stow_crafting_item([DRC.left_hand,DRC.right_hand].compact.first, @bag, nil)
            else
                DRCT.buy_item(info['stock-room'], name)
                DRCC.stow_crafting_item(name, @bag, nil)
            end
        end
    end

    def buy_material_stackables(info, materials_info, quantity, base_to_buy, base)
        # Buy stackable materials eg lumber/bone stacks
        # Total volume for max count workorder needs to be under total stackable size
        base_to_buy.times do
            DRCT.order_item(info['stock-room'], materials_info['stock-number'])
            fput("combine #{base}")
        end
        DRCC.stow_crafting_item(base, @bag, nil)
    end

    def buy_remedies(info, materials_info, item, quantity)
        herb_list = ['crushed flowers','muljin','belradi','dioica','hulnik','aloe','eghmok','lujeakave','yelith','cebi','blocil','hulij','nuloe','hisan']
        item['part'].each do |part|
            if herb_list.include?(part)
                needed = part.split(' ').last
                collect_and_process(item, needed, quantity)
                item['part'].shift # Update our parts list to remove the herb we've already purchased
            else
                quantity.times { buy_material_singles(info, materials_info[part.first], 1, part.first) } # Buy one  main herb stack for each remedy to craft
            end
        end
        item['part'] += ['water', 'alcohol'] # add the bits we might need to parts array for purchase and disposal
        item['part'].each { |part| buy_material_singles(info, materials_info[part], 1, part) } # purchase one of each of these bits
        buy_material_singles(get_data('crafting')['blacksmithing'][@hometown], materials_info['coal'], 1, 'nugget') && item['part'] += ['coal nugget'] # Buy a single coal nugget, plenty, and add it to our parts list
        return item['part'] # Return a list of parts for disposal at the end.
    end

    def finished_remedies(name, quantity)
        type,base = name.split(' ')
        until /referring/ =~ DRC.bput("get #{type} #{base} from my #{@bag}", /^You get/, /^You are already/, /^You're already/, /What were you referring to/)
            fput("combine")
        end
        return material_volume(type, base)
    end

    def calc_stock(materials_info, recipe, quantity, base = '')
        total_needed = quantity*recipe['volume']
        if base == 'ingot'
            scrap = (recipe['volume'])%materials_info['stock-volume'] > 0 ? true : false # if any left after division (%) we'll have to toss the extra bits between crafts
            return [nil, scrap] # These are not stackable, so we just need to determine if there will be leftovers out of each ingot
        elsif DRCI.exists?("#{materials_info['stock-name']} #{base}")
            /(\d+)/ =~ DRC.bput("count my #{materials_info['stock-name']} #{base}", /^You count out (\d+) (pieces|yards) of (lumber|material)/)
            on_hand_stock = Regexp.last_match(1).to_i
            return [false,false] if on_hand_stock >= (total_needed) # We have what we need, so no need to buy more.
            total_needed -= on_hand_stock # How many do we need to buy to add to what we already have.
            DRC.bput("get my #{materials_info['stock-name']} #{base} from my #{@bag}", /^You get/, /^You are already/, /^You're already/, /What were you referring to/) # have in hand to combine
        end
        
        base_to_buy = (total_needed/materials_info['stock-volume'].to_f).ceil
        scrap = (total_needed)%materials_info['stock-volume'] > 0 ? true : false

        [base_to_buy, scrap]
    end

################          PARTS HANDLING           ######################

    def buy_parts(parts, partroom)
        parts.each do |part|
            DRCT.buy_item(partroom, part)
            DRCC.stow_crafting_item(part, @bag, @belt)
        end
    end

    def order_parts(parts, quantity)
        parts.each do |part|
            data = @recipe_parts[part][@hometown]
            quantity.times do
                if data['part-number']
                    DRCT.order_item(data['part-room'], data['part-number'])
                else
                    DRCT.buy_item(data['part-room'], part)
                end
                DRCC.stow_crafting_item(part, @bag, @belt)
            end
        end
    end
    
    def trash_crafting_item(trash, info)
        DRCT.walk_to(info['trash-room'])
        DRCC.get_crafting_item(trash, @bag, @bag_items, @belt)
        DRCI.dispose_trash(trash)
    end

################    PERSONAL MATERIALS HANDLING    ######################

    ## TODO 
    ## 1. use_own_lumber
    ## 2. consolidate, maybe even move entirely to calc

    def collect_and_process(recipe, herb_needed, quantity) # can require significant outdoorsmanship skill and somewhat careful selection of an outdoors room. Alternative is just foraging and processing your own.
        unless @workorders_collect_herbs
            quantity.times { DRCC.stow_crafting_item(DRC.left_hand, @bag, nil) if redeem_deed(herb_needed) }
            return
        end
        forage_name = ['muljin sap','belradi moss','dioica sap','hulnik grass','aloe leaves','eghmok moss','lujeakave root','yelith root','cebi root','blocil berries','hulij leaves','nuloe stem','hisan flower']
        herb = forage_name.find { |h| h.include?(herb_needed) } || 'blue flower' # crushed flowers is the special case here, so unless we find a match, it defaults to blue flowers.
        DRCT.walk_to(@settings.outdoors_room)
        flowers,needed = [0,quantity] # number of individual flower stacks, representing 1 does, and 25 count stacks, representing 5 doses
        until flowers >= 5*quantity
            case DRC.bput("collect #{herb}", /^You manage to collect/, /^You.*(forage|wander) around/, /^You find something dead/, /too cluttered/)
            when /You.*(forage|wander) around/, /You find something dead/
                DRC.message("Failed to collect #{herb}. Either it cannot be found here or you don't have the skill to collect it.\nYou will have to collect your own herbs for this recipe going forwards.\nChange yaml setting: workorders_collect_herbs to false.")
                exit
            when /too cluttered/
                fput("dump junk")
                pause 60
                redo
            end
            until /(There doesn't seem to be anything left in the pile|You pick up)/ =~ DRC.bput("get #{herb}", /^You get.*a pile on the ground/, /^You pick up/, /^There doesn't seem to be anything left in the pile/) 
                DRC.bput("put my #{herb} in my #{@bag}", /^You put your/)
                flowers += 1
            end
            if checkright
                DRC.bput("put my #{herb} in my #{@bag}", /^You put your/)
                flowers += 1
            end
        end
        DRCT.walk_to(get_data('crafting')['remedies'][@hometown]['press-grinder-rooms'].first)
        process = recipe['container'] == 'bowl' ? "put my #{herb} in grinder" : "put my #{herb} in press"
        quantity.times do
            5.times do
                DRC.bput("get #{herb} from my #{@bag}", /^You get/, /^You are already/, /^You're already/, /What were you referring to/)
                DRC.bput(process, /^You place some/)
                DRC.bput("combine", /^You must be holding/, /^You combine/)
                flowers -= 1
            end
            DRCC.stow_crafting_item(DRC.left_hand, @bag, nil)
            needed -= 1
        end
        until /referring/ =~ DRC.bput("get my #{herb}", /^You get/, /^You are already/, /^You're already/, /What were you referring to/)
            DRCI.dispose_trash(herb)
        end
    end

    def redeem_deed(deed_type, base = '')
        unless /referring/ =~ DRC.bput("get #{@ordinals.first} #{deed_type} deed from my #{@workorders_deed_storage}", /^You get/, /^You are already/, /^You're already/, /^What were you referring to/)
            case DRC.bput("tap my deed", /^An attendant arrives/, /^The worker explains/, /^The deed appears to be redeemable only in one of the Crafting Society Halls/)
            when /explains/
                DRCC.stow_crafting_item('deed', @workorders_deed_storage, nil)
                @ordinals.shift
                return redeem_deed(deed_type, base)
            when /The deed appears to be redeemable only in one of the Crafting Society Halls/
                DRCC.stow_crafting_item('deed', @workorders_deed_storage, nil)
                DRCT.walk_to(@crafting_data['blacksmithing'][@hometown]['stock-room'])
                return redeem_deed(deed_type, base)
            end
            pause 0.5
            DRC.bput("get #{deed_type} #{base}", /^You pick up/, /^You are already/, /^You're already/)
            true
        else
            DRC.message("Missing the required deeds for #{deed_type}")
            false
        end
    end

    def deed_item(item)
        if /I could not find/ =~ DRC.bput('look my deed packet', /You count \d+ deed claim forms remaining/, /I could not find what you were referring to/)
            DRCM.ensure_copper_on_hand(@cash_on_hand || 10_000, @settings)
            DRCT.order_item(@deeds_room, @deeds_number)
        end
        DRC.bput("get my packet", /^You get/, /^You are already/, /^You're already/, /What were you referring to/)
        DRC.bput("get my #{item}", /^You get/, /^You are already/, /^You're already/, /What were you referring to/)
        DRC.bput("push my #{item} with packet", /^You push/)
        DRCC.stow_crafting_item("packet", @bag, nil)
        DRCC.stow_crafting_item("deed", @workorders_deed_storage, nil)
    end

    def ingot_volume(material)
        DRC.bput("analyze my #{material} ingot", /About \d+ volume/).scan(/\d+/).first.to_i
    end

    def material_volume(type, base)
        DRC.bput("count my #{type} #{base}", /^You count out (\d+) (pieces|uses|yards).*(lumber|remaining|material)/).scan(/\d+/).first.to_i
    end

    def deed_volume(material)
        DRC.bput("read my #{material} deed", /Volume:\s*\d+/, /Amount:\s*\d+/, /Pieces:\s*\d+/).scan(/\d+/).first.to_i
    end

    def check_own_materials(item, quantity, type, base)
        volume = 0
        while volume < (item['volume'] * quantity)
            unless /referring/ =~ DRC.bput("get #{type} #{base} from my #{@bag}", /^You get/, /^You are already/, /^You're already/, /^What were you referring to/)
                volume = material_volume(type, base)
                next
            end
            if volume < (item['volume'] * quantity)
                if redeem_deed(type, base)
                    if [DRC.right_hand,DRC.left_hand].compact.size > 1
                        fput("combine")
                    end
                    volume += material_volume(type, base)
                else
                    DRC.message("Out of #{base} and deeds")
                    DRCI.stow_hands
                    return false
                end
            end
        end
        true
    end

    def check_own_ingot(item, quantity, type)
        if /referring/ =~ DRC.bput("get my #{type} ingot", /^You get/, /^You are already/, /^You're already/, /^What were you referring to/) 
            if volume = deed_volume(type)                
                redeem_deed(type, 'ingot')
            else
                echo('out of material/deeds')
                return false
            end
        end

        volume ||= ingot_volume(type)

        DRCI.stow_hands
        @smelt = false

        if volume < quantity * item['volume']
            @smelt = true
            if volume = deed_volume(type)
                redeem_deed(type, 'ingot')
            else
                echo('out of material/deeds')
                return false
            end
        end

        DRCI.stow_hands

        if volume < quantity * item['volume']
            echo('out of material/deeds')
            smelt(type)
            return check_own_ingot(item, quantity, type)
        end

        true
    end

    def smelt(type)
        DRCC.find_empty_crucible(@hometown)
        2.times do
            DRC.bput("get my #{type} ingot", /^You get/, /^You are already/, /^You're already/, /What were you referring to/)
            fput('put my ingot in cruc')
        end
        DRC.wait_for_script_to_complete('smelt')
        DRCI.stow_hands
    end

################       TASK MASTER HANDLING        ######################

    def request_work_order(recipes, npc_rooms, npc, npc_last_name, discipline, logbook, diff)
        match_names = recipes.map { |x| x['name'] }
        diff ||= 'challenging'
        DRCI.stow_hands
        500.times do
            find_npc(npc_rooms, npc_last_name)
            DRC.bput("get my #{logbook} logbook", 'You get') unless DRC.left_hand || DRC.right_hand
            case DRC.bput("ask #{npc} for #{diff} #{discipline} work", '^To whom', 'order for .* I need \d+ ', 'order for .* I need \d+ stacks \(5 uses each\) of .* quality', 'You realize you have items bundled with the logbook', 'You want to ask about shadowlings')
            when 'You want to ask about shadowlings'
                pause 10
                fput('say Hmm.')
            when /order for (.*)\. I need (\d+) /
                item = Regexp.last_match(1)
                quantity = Regexp.last_match(2).to_i
                if @min_items <= quantity && quantity <= @max_items && match_names.include?(item)
                    DRCC.stow_crafting_item('logbook', @bag, nil)
                    return [item, quantity]
                end
            when /order for (.*)\. I need (\d+) stacks \(5 uses each\) of .* quality/
                item = Regexp.last_match(1)
                quantity = Regexp.last_match(2).to_i
                if @min_items <= quantity && quantity <= @max_items && match_names.include?(item)
                    DRCC.stow_crafting_item('logbook')
                    return [item, quantity]
                end
            when 'You realize you have items bundled with the logbook'
                DRC.bput('untie my logbook', 'You untie')
                if DRC.left_hand.include?('logbook')
                    fput("drop my #{DRC.right_hand}")
                else
                    fput("drop my #{DRC.left_hand}")
                end
                fput('get logbook') unless [DRC.left_hand, DRC.right_hand].grep(/logbook/i).any?
            end
        end
        DRCC.stow_crafting_item('logbook', @bag, nil)
        exit
    end    

    def log_remedy(name, quantity)
        return unless name
        quantity.times do
            DRC.bput("mark my #{name} at 5", /^You measure out/, /^There is not enough/, /^You must be holding/) # if we have exactly the number required, the last remedy won't mark
            DRC.bput("break my #{name}", /^You carefully break off/, /^You can't break that/) # and won't break. Bundles fine.
            DRCC.stow_crafting_item(name, @bag, nil)
        end
        mod = ''
        if checkleft
            mod = 'second'
            DRCC.stow_crafting_item(name, @bag, nil)
        end
        DRC.bput("get my alchemy logbook", 'You get')
        quantity.times do
            DRC.bput("get #{mod} #{name} from my #{@bag}", /^You get/, /^You are already/, /^You're already/, /What were you referring to/)
            unless /You notate the/ =~ DRC.bput("bundle my #{name} with my logbook", /^You notate the/, /^The workorder requires/)
                DRCT.dispose(name)
            end
        end
        DRC.bput("put my alchemy logbook in my #{@bag}", 'You put', 'What were you referring to')
    end

    def complete_work_order(info)
        DRCI.stow_hands
        loop do
            find_npc(info['npc-rooms'], info['npc_last_name'])
            DRC.bput("get my #{info['logbook']} logbook", 'You get')
            DRC.release_invisibility
            case DRC.bput("give my #{info['logbook']} logbook to #{info['npc']}", /You hand/, /You can/, /What were you/, /Apparently the work order time limit has expired/, /The work order isn\'t yet complete/, /What is it you\'re trying to give/)
            when /You can/, /What were you/, /What is it/
                next
            end
            break
        end
        DRCC.stow_crafting_item('logbook', @bag, nil)
    end

    def find_npc(room_list, npc)
        room_list.each do |room_id|
            break if DRRoom.npcs.include?(npc)
            DRCT.walk_to(room_id)
        end
    end
end

before_dying do
  Flags.delete('proper-repair')
end

WorkOrders.new
